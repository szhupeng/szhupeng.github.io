<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Kotlin," />










<meta name="description" content="类和继承类Kotlin中类用class声明： 12class Invoice &amp;#123;&amp;#125; 类的声明由类名，类头（指定其类型参数，主构造函数等）和类主体组成，用大括号括起来。类头和类主体都是可选的; 如果类没有主体，可以省略大括号。 1class Empty">
<meta name="keywords" content="Kotlin">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin类和对象">
<meta property="og:url" content="http://zhupeng.space/2017/06/18/kotlin-classes/index.html">
<meta property="og:site_name" content="Coding Life">
<meta property="og:description" content="类和继承类Kotlin中类用class声明： 12class Invoice &amp;#123;&amp;#125; 类的声明由类名，类头（指定其类型参数，主构造函数等）和类主体组成，用大括号括起来。类头和类主体都是可选的; 如果类没有主体，可以省略大括号。 1class Empty">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-07-01T02:15:22.576Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kotlin类和对象">
<meta name="twitter:description" content="类和继承类Kotlin中类用class声明： 12class Invoice &amp;#123;&amp;#125; 类的声明由类名，类头（指定其类型参数，主构造函数等）和类主体组成，用大括号括起来。类头和类主体都是可选的; 如果类没有主体，可以省略大括号。 1class Empty">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://zhupeng.space/2017/06/18/kotlin-classes/"/>





  <title>Kotlin类和对象 | Coding Life</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coding Life</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">思路决定出路</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhupeng.space/2017/06/18/kotlin-classes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱鹏">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ob0r3vf26.bkt.clouddn.com/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding Life">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Kotlin类和对象</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-18T08:12:36+08:00">
                2017-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/18/kotlin-classes/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/06/18/kotlin-classes/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/06/18/kotlin-classes/" class="leancloud_visitors" data-flag-title="Kotlin类和对象">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="类和继承"><a href="#类和继承" class="headerlink" title="类和继承"></a>类和继承</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>Kotlin中类用class声明：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoice</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类的声明由类名，类头（指定其类型参数，主构造函数等）和类主体组成，用大括号括起来。类头和类主体都是可选的; 如果类没有主体，可以省略大括号。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>Kotlin中类可以有一个主构造函数和一个或多个二级构造函数。主构造函数是类头的一部分：跟在类名后面（并有可选的类型参数）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(firstName: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果主构造函数没有任何注解或可见性修饰符，那么可以省略<strong>constructor</strong>关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(firstName: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主构造函数不能包含任何代码。初始化代码可以放在以<strong>init</strong>关键字作为前缀的初始化块内：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>(name: String) &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        logger.info(<span class="string">"Customer initialized with value <span class="subst">$&#123;name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：初始化块中可以使用主构造函数的参数。也可以用在类的属性初始化声明中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">val</span> customerKey = name.toUpperCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，声明属性并从主构造函数中初始化，Kotlin有一个简洁的语法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> firstName: String, <span class="keyword">val</span> lastName: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与普通属性相同，主构造函数中声明的属性可以是可变的（var）或只读的（val）。</p>
<p>如果构造函数具有注解或可见性修饰符，则<strong>constructor</strong>关键字是必需的，并且可见性修饰符在前：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">public</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(name: String) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="二级构造函数"><a href="#二级构造函数" class="headerlink" title="二级构造函数"></a>二级构造函数</h3><p>类还可以声明二级构造函数，以<strong>constructor</strong>为前缀：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(parent: Person) &#123;</span><br><span class="line">        parent.children.add(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果类具有主构造函数，则每个二级构造函数需要通过另一个二级构造函数直接或间接地委托给主构造函数。使用<strong>this</strong>关键字对同一类的另一个构造函数进行委托：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String, parent: Person) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        parent.children.add(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个非抽象类没有声明任何构造函数（主构造函数或二级构造函数），那么它将生成没有参数的主构造函数。该构造函数的可见性是公共的（public）。如果不希望类具有公共的构造函数，则需要声明具有非默认可见性的空主构造函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DontCreateMe</span> <span class="keyword">private</span> <span class="keyword">constructor</span> </span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在JVM虚拟机中，如果主构造函数的所有参数都具有默认值，编译器将生成一个额外的无参数构造函数，该构造函数将使用默认值。这使得Kotlin可以更容易的使用像Jackson或者JPA这类使用无参构造函数来创建类实例的库。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>(<span class="keyword">val</span> customerName: String = <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<h3 id="创建类的实例"><a href="#创建类的实例" class="headerlink" title="创建类的实例"></a>创建类的实例</h3><p>可以像调用普通函数那样调用构造函数来创建类的实例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> invoice = Invoice()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> customer = Customer(<span class="string">"Joe Smith"</span>)</span><br></pre></td></tr></table></figure>
<p>注意：Kotlin中没有<strong>new</strong>关键字。</p>
<h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><p>类可以包含：</p>
<ul>
<li>构造函数和初始化代码块</li>
<li>函数</li>
<li>属性</li>
<li>嵌套内部类</li>
<li>对象声明</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Kotlin中的所有类都有一个共同的父类<strong>Any</strong>，Any是一个没有声明父类的类的默认父类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> // <span class="title">Implicitly</span> <span class="title">inherits</span> <span class="title">from</span> <span class="title">Any</span></span></span><br></pre></td></tr></table></figure>
<p><strong>Any</strong>不是<strong>java.lang.Object</strong>；事实上它除了<strong>equals()</strong>, <strong>hashCode()</strong>和<strong>toString()</strong>外没有任何成员。</p>
<p>要声明一个明确的父类，需要将父类放在类头部的冒号后面：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>(p: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(p: <span class="built_in">Int</span>) : Base(p)</span><br></pre></td></tr></table></figure>
<p>如果类有主构造函数，则基类可以（而且必须）在主构造函数中使用主构造函数的参数进行初始化。</p>
<p>如果类没有主构造函数，则每个二级构造函数必须使用<strong>super</strong>关键字初始化基类，或者委托给另一个构造函数。请注意，在这种情况下，不同的二级构造函数可以调用基类不同的构造函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span> : <span class="type">View &#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(ctx: Context) : <span class="keyword">super</span>(ctx)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(ctx: Context, attrs: AttributeSet) : <span class="keyword">super</span>(ctx, attrs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类的<strong>open</strong>注解和java中的final相反：它允许其他类继承这个类。默认情况下，<br>Kotlin中的所有类都是final的。</p>
<h3 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h3><p>正如之前提到的，kotlin要坚持做明确的事。与Java不同的是，Kotlin需要对可重写的成员（称之为open）进行显式注释并且重写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nv</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>() : Base() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Derived.v()需要<strong>override</strong>注解。如果缺少，编译器会提示。如果在一个函数上没有<strong>open</strong>注解，像Base.nv()，在子类中声明一个具有相同签名的方法是不合法的，无论加了override还是没有加。在一个final类（例如没有open注解的类）中，open类型的成员是不允许的。</p>
<p>标注为<strong>override</strong>的成员本身是open的，可以在子类中被重写。如果要禁止重写，可以使用<strong>final</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherDerived</span></span>() : Base() &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h3><p>重写属性的方式与重写方法类似；在父类中声明然后在派生类上重新声明的属性必须添加<strong>override</strong>，并且它们必须具有兼容的类型。每个声明的属性都可以被具有初始化器的属性或具有getter方法的属性覆盖。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> <span class="keyword">get</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar1</span> : <span class="type">Foo</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> = ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以使用<strong>var</strong>属性覆盖<strong>val</strong>属性，反之亦然。这是允许的，因为<strong>val</strong>属性本质上声明了一个getter方法，并将其重写为var，另外在派生类中声明一个setter方法。</p>
<p>注意：可以在主构造函数中使用override关键字作为属性声明的一部分。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar1</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> count: <span class="built_in">Int</span>) : Foo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar2</span> : <span class="type">Foo &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> count: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重写规则"><a href="#重写规则" class="headerlink" title="重写规则"></a>重写规则</h3><p>在Kotlin中，实现继承遵循如下规则：如果一个类从其直接父类继承同一成员的多个实现，则它必须重写该成员并提供自己的实现（或许只是直接用了继承来的实现）。为了表示从父类继承的实现，使用<strong>super</strong>并跟上使用了父类名称的尖括号。例如super&lt;Base&gt;：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123; print(<span class="string">"A"</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">()</span></span> &#123; print(<span class="string">"a"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123; print(<span class="string">"B"</span>) &#125; <span class="comment">// interface members are 'open' by default</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">b</span><span class="params">()</span></span> &#123; print(<span class="string">"b"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>() : A(), B &#123;</span><br><span class="line">    <span class="comment">// The compiler requires f() to be overridden:</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;A&gt;.f() <span class="comment">// call to A.f()</span></span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.f() <span class="comment">// call to B.f()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以同时从A和B中继承方法，并且C继承a()和b()没有任何问题，因为都只有一个实现。但是对于f()有两个由C继承的实现，因此必须在C中重写f()，并提供自己的实现消除歧义。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>一个类和其一些成员可以被声明为<strong>abstract</strong>。抽象成员在其类中没有实现。注意：不需要使用<strong>open</strong>来注解抽象类或函数-不言而喻。</p>
<p>可以用抽象成员重写一个带open注解的非抽象成员：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="type">Base</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="伴随对象"><a href="#伴随对象" class="headerlink" title="伴随对象"></a>伴随对象</h3><p>在Kotlin中，与Java或C＃不同，类没有静态方法。在大多数情况下，建议简单地使用包级别函数代替。</p>
<p>如果需要编写一个可以调用的函数，而不需要一个类实例，但需要访问类的内部（例如，一个工厂方法），则可以将其作为该类中对象声明的成员编写。</p>
<p>更具体地说，如果在类中声明了一个伴随对象，则可以像Java/C＃中调用静态方法那样，直接使用类名来调用其成员。</p>
<h2 id="属性和字段"><a href="#属性和字段" class="headerlink" title="属性和字段"></a>属性和字段</h2><h3 id="声明属性"><a href="#声明属性" class="headerlink" title="声明属性"></a>声明属性</h3><p>Kotlin中的类可以拥有属性。属性可以用<strong>var</strong>关键字声明为可变的或用<strong>val</strong>关键字声明为只读的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = ...</span><br><span class="line">    <span class="keyword">var</span> street: String = ...</span><br><span class="line">    <span class="keyword">var</span> city: String = ...</span><br><span class="line">    <span class="keyword">var</span> state: String? = ...</span><br><span class="line">    <span class="keyword">var</span> zip: String = ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以像Java中的字段一样，使用名称来引用一个属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copyAddress</span><span class="params">(address: <span class="type">Address</span>)</span></span>: Address &#123;</span><br><span class="line">    <span class="keyword">val</span> result = Address() <span class="comment">// there's no 'new' keyword in Kotlin</span></span><br><span class="line">    result.name = address.name <span class="comment">// accessors are called</span></span><br><span class="line">    result.street = address.street</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Getter和Setter"><a href="#Getter和Setter" class="headerlink" title="Getter和Setter"></a>Getter和Setter</h3><p>声明属性的完整语法是：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure>
<p>在初始化语句中，getter和setter都是可选的。如果可以从初始化语句（或从getter返回类型）推断出属性类型，则属性类型是可选的。</p>
<p>例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allByDefault: <span class="built_in">Int</span>? <span class="comment">// error: explicit initializer required, default getter and setter implied</span></span><br><span class="line"><span class="keyword">var</span> initialized = <span class="number">1</span> <span class="comment">// has type Int, default getter and setter</span></span><br></pre></td></tr></table></figure>
<p>只读属性声明的完整语法与可变的属性声明有两点不同：<strong>以val而不是var开头，不允许有setter函数</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> simple: <span class="built_in">Int</span>? <span class="comment">// has type Int, default getter, must be initialized in constructor</span></span><br><span class="line"><span class="keyword">val</span> inferredType = <span class="number">1</span> <span class="comment">// has type Int and a default getter</span></span><br></pre></td></tr></table></figure>
<p>可以在属性声明中写入自定义访问器，访问器非常像普通函数。一个自定义getter的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>一个自定义setter：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringRepresentation: String</span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.toString()</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        setDataFromString(value) <span class="comment">// parses the string and assigns values to other properties</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>按照惯例，setter函数的参数名称是value，但是也可以选择不同的名称。</p>
<p>从Kotlin1.1开始，如果可以从getter推断属性类型，则可以省略类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEmpty <span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span>  <span class="comment">// has type Boolean</span></span><br></pre></td></tr></table></figure>
<p>如果需要更改访问器的可见性或对其进行注解，但不需要更改其默认实现，则可以定义不带函数体的访问器：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setterVisibility: String = <span class="string">"abc"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span> <span class="comment">// the setter is private and has the default implementation</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> setterWithAnnotation: Any? = <span class="literal">null</span></span><br><span class="line">    <span class="meta">@Inject</span> <span class="keyword">set</span> <span class="comment">// annotate the setter with Inject</span></span><br></pre></td></tr></table></figure>
<h3 id="后备字段（Backing-Fields）"><a href="#后备字段（Backing-Fields）" class="headerlink" title="后备字段（Backing Fields）"></a>后备字段（Backing Fields）</h3><p>Kotlin中类不能有字段。但是，有时在使用自定义访问器时需要有一个后备字段。出于这点，Kotlin提供了可以使用<strong>field</strong>标识符访问的自动后备字段：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span> <span class="comment">// the initializer value is written directly to the backing field</span></span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) field = value</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>field</strong>标识符只能在属性的访问器中使用。</p>
<p>如果属性使用至少一个访问器的默认实现，或者自定义访问器通过<strong>field</strong>标识符引用该属性，则编译器将为属性生成后备字段。</p>
<p>例如，在以下情况下，将不会有后备字段：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="后备属性（Backing-Properties）"><a href="#后备属性（Backing-Properties）" class="headerlink" title="后备属性（Backing Properties）"></a>后备属性（Backing Properties）</h3><p>如果有些方案不适合使用这种“隐性后备字段”，可以使用后备属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _table: Map&lt;String, <span class="built_in">Int</span>&gt;? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> table: Map&lt;String, <span class="built_in">Int</span>&gt;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_table == <span class="literal">null</span>) &#123;</span><br><span class="line">            _table = HashMap() <span class="comment">// Type parameters are inferred</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _table ?: <span class="keyword">throw</span> AssertionError(<span class="string">"Set to null by another thread"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>综合来讲，与Java一样，因为使用带有默认getter和setter函数的私有属性的访问被优化过，因此不会引入函数调用开销。</p>
<h3 id="编译时常量"><a href="#编译时常量" class="headerlink" title="编译时常量"></a>编译时常量</h3><p>在编译时就已知其具体值的属性可以使用<strong>const</strong>修饰符标注为<em>编译时常量</em>。这些属性需要满足以下要求：</p>
<ul>
<li>在顶级声明的或者是object的成员（Top-level or member of an object）</li>
<li>初始化为<strong>String</strong>类型或基本类型的值</li>
<li>没有自定义getter函数</li>
</ul>
<p>这些属性可以在注解中使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">val</span> SUBSYSTEM_DEPRECATED: String = <span class="string">"This subsystem is deprecated"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated(SUBSYSTEM_DEPRECATED)</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="延迟初始化属性（Late-Initialized-Properties）"><a href="#延迟初始化属性（Late-Initialized-Properties）" class="headerlink" title="延迟初始化属性（Late-Initialized Properties）"></a>延迟初始化属性（Late-Initialized Properties）</h3><p>通常，声明为非空类型的属性必须在构造函数中初始化。但是，相当多的时候这并不方便。例如，可以通过依赖注入或单元测试的setup方法初始化属性。在这种情况下，不能在构造函数中提供非空的初始值，但是在类体中引用属性时，仍然希望避免空检查。</p>
<p>要处理这种情况，可以使用<strong>lateinit</strong>修饰符标注属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> subject: TestSubject</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SetUp</span> <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        subject = TestSubject()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        subject.method()  <span class="comment">// dereference directly</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lateinit修饰符只能用于在一个类体中声明的<strong>var</strong>属性（不能在主构造函数中），并且只有在属性没有自定义的getter或setter时才可以使用。属性的类型必须为非空，并且不能为基本类型。</p>
<p>在初始化之前访问一个<strong>lateinit</strong>属性会抛出一个特定异常，该异常会说明访问属性的时候值还没有初始化。</p>
<h3 id="委托属性（Delegated-Properties）"><a href="#委托属性（Delegated-Properties）" class="headerlink" title="委托属性（Delegated Properties）"></a>委托属性（Delegated Properties）</h3><p>最常见的属性只是读取（也可能写入）一个后备字段。另一方面，使用自定义getter和setter可以实现属性的任何行为。介于两者之间 ，属性如何运作有一些共同的模式。几个例子：懒值（lazy values），通过给定键值从map中读取，访问数据库，通知监听器等。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Kotlin中的接口与Java 8非常相似。可以包含抽象方法的声明以及方法实现。与抽象类不同的是接口不能保存状态。接口可以具有属性，但必须是抽象的或提供访问器实现。</p>
<p>使用<strong>interface</strong>关键字定义接口：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// optional body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>一个类或对象可以实现一个或多个接口：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> : <span class="type">MyInterface &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口中的属性"><a href="#接口中的属性" class="headerlink" title="接口中的属性"></a>接口中的属性</h3><p>可以在接口中声明属性。在接口中声明的属性要么是抽象的，要么提供访问器的实现。在接口中声明的属性不能具有后备字段，因此在接口中声明的访问器不能引用它们。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> prop: <span class="built_in">Int</span> <span class="comment">// abstract</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> propertyWithImplementation: String</span><br><span class="line">        <span class="keyword">get</span>() = <span class="string">"foo"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        print(prop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> : <span class="type">MyInterface &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> prop: <span class="built_in">Int</span> = <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解决重写冲突"><a href="#解决重写冲突" class="headerlink" title="解决重写冲突"></a>解决重写冲突</h3><p>当在父类列表中声明很多类型时，可能会继承同一个方法的多个实现。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">"A"</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">"B"</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; print(<span class="string">"bar"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> : <span class="type">A &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; print(<span class="string">"bar"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> : <span class="type">A</span>, <span class="type">B &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;A&gt;.foo()</span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.foo()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.bar()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口A和B都声明了函数foo()和bar()。都实现了foo()，但只有B实现了bar()（bar()在A中没有标注为abstract，因为在接口中如果函数没有函数体，默认是抽象的）。现在，如果从A派生一个具体的类C，显然必须重写bar())并提供一个实现。</p>
<p>然而，如果从A和B派生D，需要实现从多个接口继承的所有方法，并指出D应该如何实现它们。此规则既适用于继承单个实现（bar()）的方法也适用于继承多个实现（foo()）的方法。</p>
<h2 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h2><p>类，对象，接口，构造函数，函数，属性及其setter方法都可以具有可见性修饰符。（getter方法总是具有与属性相同的可见性）Kotlin中有四个可见性修饰符：<strong>private</strong>，<strong>protected</strong>，<strong>internal</strong>和<strong>public</strong>。如果没有显式修饰符，则默认为<strong>public</strong>。</p>
<p>下面是不同类型声明范围的说明。</p>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>函数，属性和类，对象和接口可以在“顶级（top-level）”上声明，即直接在包中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file name: example.kt</span></span><br><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">baz</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果没有指定任何可见性修饰符，则默认使用<strong>public</strong>，这意味着声明将在任何地方都可见;</li>
<li>如果声明为<strong>private</strong>，则只会在包含声明的文件内部可见;</li>
<li>如果声明为<strong>internal</strong>，则在同一<span style="color:#497bb7">模块</span>中的任何地方可见;</li>
<li><strong>protected</strong>不可用于顶级（top-level）声明中。</li>
</ul>
<p>例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file name: example.kt</span></span><br><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125; <span class="comment">// visible inside example.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> bar: <span class="built_in">Int</span> = <span class="number">5</span> <span class="comment">// property is visible everywhere</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span>         <span class="comment">// setter is visible only in example.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> baz = <span class="number">6</span>    <span class="comment">// visible inside the same module</span></span><br></pre></td></tr></table></figure>
<h3 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h3><p>对于在类中声明的成员：</p>
<ul>
<li><strong>private</strong>意味着只在该类（包括其所有成员）中可见;</li>
<li><strong>protected</strong>和<strong>private</strong>一样，但在子类中也可见;</li>
<li><strong>internal</strong>在本模块内的任何可以看到声明类的地方都看到该类的所有<strong>internal</strong>成员;</li>
<li><strong>public</strong>任何可以看到声明类的地方都可以看到该类的<strong>public</strong>成员。</li>
</ul>
<p>注意：在Kotlin中，外部类不可以访问其内部类的私有（private）成员。</p>
<p>如果重写<strong>protected</strong>成员并且没有明确指定可见性，则重写的成员也将具有<strong>protected</strong>可见性。</p>
<p>例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">open</span> <span class="keyword">val</span> b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> c = <span class="number">3</span></span><br><span class="line">    <span class="keyword">val</span> d = <span class="number">4</span>  <span class="comment">// public by default</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> e: <span class="built_in">Int</span> = <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass</span> : <span class="type">Outer</span></span>() &#123;</span><br><span class="line">    <span class="comment">// a is not visible</span></span><br><span class="line">    <span class="comment">// b, c and d are visible</span></span><br><span class="line">    <span class="comment">// Nested and e are visible</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> b = <span class="number">5</span>   <span class="comment">// 'b' is protected</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unrelated</span></span>(o: Outer) &#123;</span><br><span class="line">    <span class="comment">// o.a, o.b are not visible</span></span><br><span class="line">    <span class="comment">// o.c and o.d are visible (same module)</span></span><br><span class="line">    <span class="comment">// Outer.Nested is not visible, and Nested::e is not visible either</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>要指定类的主构造函数的可见性，请使用以下语法（请注意，必须显示添加一个constructor关键字）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(a: <span class="built_in">Int</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>这里的构造函数是私有的。默认情况下，所有构造函数都是<strong>public</strong>的，只要类可见的地方它们就可见（即<strong>internal</strong>类型的类的构造函数只能在同一模块中可见）。</p>
<h3 id="局部声明"><a href="#局部声明" class="headerlink" title="局部声明"></a>局部声明</h3><p>局部变量，函数和类不能有可见性修饰符。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p><strong>internal</strong>可见性修饰符意味着成员在同一模块中可见。更具体地说，一个模块是一组编译在一起的Kotlin文件：</p>
<p>– 一个IntelliJ IDEA中的模块;<br><br>– 一个Maven或者Gradle工程;<br><br>– 通过一次调用Ant任务编译的一组文件。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>Kotlin，类似于C＃和Gosu，提供了对类进行功能扩展的能力，而不必继承类或使用任何类型的设计模式，如Decorator。这是通过称为扩展的特殊声明完成的。Kotlin支持函数扩展和属性扩展。</p>
<h3 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h3><p>要声明一个函数扩展，需要用一个接收者类型（receiver type）的名称作为函数的前缀。以下为MutableList&lt;Int&gt;添加swap函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> MutableList<span class="type">&lt;Int&gt;</span>.<span class="title">swap</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tmp = <span class="keyword">this</span>[index1] <span class="comment">// 'this' corresponds to the list</span></span><br><span class="line">    <span class="keyword">this</span>[index1] = <span class="keyword">this</span>[index2]</span><br><span class="line">    <span class="keyword">this</span>[index2] = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展函数中的<span style="color:#497bb7">this</span>关键字对应于接收者对象（the one that is passed before the dot） 现在，可以在任何MutableList&lt;Int&gt;上调用这样一个函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">l.swap(<span class="number">0</span>, <span class="number">2</span>) <span class="comment">// 'this' inside 'swap()' will hold the value of 'l'</span></span><br></pre></td></tr></table></figure>
<p>当然，这个函数对于任何MutableList&lt;T&gt;都是适用的，并且可以使它成为通用的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableList<span class="type">&lt;T&gt;</span>.<span class="title">swap</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tmp = <span class="keyword">this</span>[index1] <span class="comment">// 'this' corresponds to the list</span></span><br><span class="line">    <span class="keyword">this</span>[index1] = <span class="keyword">this</span>[index2]</span><br><span class="line">    <span class="keyword">this</span>[index2] = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数名之前声明通用类型参数，使其在接收者类型表达式中可用。</p>
<h3 id="扩展是被静态解析的"><a href="#扩展是被静态解析的" class="headerlink" title="扩展是被静态解析的"></a>扩展是被静态解析的</h3><p>扩展实际上并不修改它们扩展的类。通过定义扩展名，并没有将新成员插入到类中，而只是让该类的实例变量能使用 <strong>.</strong> 来调用新函数。</p>
<p>扩展函数是静态调度的，即它们不是接收者类型虚拟的。这意味着被调用的扩展函数由调用该函数的表达式的类型决定，而不是在运行时获得的表达式的类型决定。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>: <span class="type">C</span></span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"c"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"d"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printFoo</span><span class="params">(c: <span class="type">C</span>)</span></span> &#123;</span><br><span class="line">    println(c.foo())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printFoo(D())</span><br></pre></td></tr></table></figure>
<p>该示例将打印“c”，因为被调用的扩展函数仅取决于参数c（C类）的声明类型。</p>
<p>如果一个类有一个成员函数，并且定义了一个扩展函数，它们具有相同的接收者类型，相同的名称并且给定的参数也相同，则调用的时候会使用成员函数。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">"member"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">"extension"</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>如果C类的任何实例c调用c.foo()，将打印“member”而不是“extension”。</p>
<p>但是，扩展函数可以重载具有相同名称但不同签名的成员函数，这是完全正确的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">"member"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">(i: <span class="type">Int</span>)</span></span> &#123; println(<span class="string">"extension"</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>调用C().foo(1)将打印“extension”。</p>
<h3 id="可空接收者（Nullable-Receiver）"><a href="#可空接收者（Nullable-Receiver）" class="headerlink" title="可空接收者（Nullable Receiver）"></a>可空接收者（Nullable Receiver）</h3><p>注意：可以使用可空接收者类型定义扩展。这样的扩展可以在对象变量上调用，即使它的值为null，并且可以在扩展内部检查this == null。这样可以调用Kotlin中的toString()方法，而不必检查null：检查发生在扩展函数内。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Any?.<span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"null"</span></span><br><span class="line">    <span class="comment">// after the null check, 'this' is autocast to a non-null type, so the toString() below</span></span><br><span class="line">    <span class="comment">// resolves to the member function of the Any class</span></span><br><span class="line">    <span class="keyword">return</span> toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性扩展"><a href="#属性扩展" class="headerlink" title="属性扩展"></a>属性扩展</h3><p>与函数类似，Kotlin支持属性扩展：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;T&gt; List&lt;T&gt;.lastIndex: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = size - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>注意：由于扩展并不是真正将成员插入到类中，因此扩展属性无法拥有后备字段。这就是为什么<strong>扩展属性不允许有初始化器</strong>。扩展属性的行为只能通过明确提供getter/setter来定义。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Foo.bar = <span class="number">1</span> <span class="comment">// error: initializers are not allowed for extension properties</span></span><br></pre></td></tr></table></figure>
<h3 id="伴随对象扩展"><a href="#伴随对象扩展" class="headerlink" title="伴随对象扩展"></a>伴随对象扩展</h3><p>如果一个类定义了伴随对象，那么还可以定义伴随对象的扩展函数和扩展属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123; &#125;  <span class="comment">// will be called "Companion"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> MyClass.Companion.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像伴随对象的普通成员一样，只能使用类名作为限定词：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass.foo()</span><br></pre></td></tr></table></figure>
<h3 id="扩展的域"><a href="#扩展的域" class="headerlink" title="扩展的域"></a>扩展的域</h3><p>大多数时间都是在顶级（top level）定义扩展，即直接在包下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo.bar</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Baz.<span class="title">goo</span><span class="params">()</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>要在其声明包之外使用这种扩展，需要在import时导入：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.usage</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo.bar.goo <span class="comment">// importing all extensions by name "goo"</span></span><br><span class="line">                   <span class="comment">// or</span></span><br><span class="line"><span class="keyword">import</span> foo.bar.*   <span class="comment">// importing everything from "foo.bar"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">usage</span><span class="params">(baz: <span class="type">Baz</span>)</span></span> &#123;</span><br><span class="line">    baz.goo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="声明扩展作为成员"><a href="#声明扩展作为成员" class="headerlink" title="声明扩展作为成员"></a>声明扩展作为成员</h3><p>在类中，可以声明另一个类的扩展。在这样的扩展中，有多个隐式接收者（implicit receivers） - 可以在没有限定符的情况下访问该接收者的对象成员。声明了扩展的类的实例称为分发接收者（dispatch receiver），扩展方法的接收者的实例称为扩展接收者（extension receiver）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">baz</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        bar()   <span class="comment">// calls D.bar</span></span><br><span class="line">        baz()   <span class="comment">// calls C.baz</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">caller</span><span class="params">(d: <span class="type">D</span>)</span></span> &#123;</span><br><span class="line">        d.foo()   <span class="comment">// call the extension function</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在分发接收者的成员与扩展接收者的成员之间发生命名冲突的情况下，分发接收者优先。要引用分发接收者的成员，可以使用this使用范围（Qualified this）语法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        toString()         <span class="comment">// calls D.toString()</span></span><br><span class="line">        <span class="keyword">this</span><span class="symbol">@C</span>.toString()  <span class="comment">// calls C.toString()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明为成员的扩展可以在子类中被声明为<strong>open</strong>和<strong>override</strong>。这意味着这种函数的调度对于分发接收者类型是虚拟的，但是对于扩展接收器类型是静态的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> : <span class="type">D</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D.foo in C"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> D1.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D1.foo in C"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">caller</span><span class="params">(d: <span class="type">D</span>)</span></span> &#123;</span><br><span class="line">        d.foo()   <span class="comment">// call the extension function</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> : <span class="type">C</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D.foo in C1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> D1.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D1.foo in C1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C().caller(D())   <span class="comment">// prints "D.foo in C"</span></span><br><span class="line">C1().caller(D())  <span class="comment">// prints "D.foo in C1" - dispatch receiver is resolved virtually</span></span><br><span class="line">C().caller(D1())  <span class="comment">// prints "D.foo in C" - extension receiver is resolved statically</span></span><br></pre></td></tr></table></figure>
<h3 id="动机（Motivation）"><a href="#动机（Motivation）" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h3><p>在Java中，习惯使用名为“*Utils”的类：FileUtils，StringUtils等。著名的java.util.Collections属于其中之一。关于这些Utils类令人不快的部分是使用它们的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line">Collections.swap(list, Collections.binarySearch(list, Collections.max(otherList)), Collections.max(list))</span><br></pre></td></tr></table></figure>
<p>这些类名总是一成不变的。可以使用静态导入并这样使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line">swap(list, binarySearch(list, max(otherList)), max(list))</span><br></pre></td></tr></table></figure>
<p>这样更好的一点，但这样只能从IDE自动完成代码那里获得很少或得不到帮助信息。 如果像下面这样就好多了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line">list.swap(list.binarySearch(otherList.max()), list.max())</span><br></pre></td></tr></table></figure>
<p>但又不想在List类中实现所有可能的方法。这就是扩展带来的好处。</p>
<h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><p>我们经常创建一个只能保存数据类。在这样的类中，一些标准函数通常是从数据中机械推导出来的。在Kotlin中，这被称为数据类（data class），并被标注为<strong>data</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>
<p>编译器会自动从主构造函数中声明的所有属性导出以下成员：</p>
<ul>
<li>equals()/hashCode()对</li>
<li>形式为“User(name = John，age = 42)”的toString()</li>
<li><span style="color:#497bb7">componentN() functions</span>以属性的声明顺序对应到属性</li>
<li>copy()函数</li>
</ul>
<p>如果这些函数中的任何一个在类中被显式定义，或者从基类继承，则不会被生成。</p>
<p>为了确保生成代码的一致性和有意义的行为，数据类必须满足以下要求：</p>
<ul>
<li>主构造函数需要至少有一个参数;</li>
<li>主构造函数的所有参数都需要标注为val或var;</li>
<li>数据类不能是abstract，open，sealed或inner;</li>
<li>（1.1之前）数据类只能实现接口</li>
</ul>
<p>从1.1以后，数据类可以继承其他类。</p>
<p>在JVM中，如果生成的类需要有一个无参数的构造函数，则必须指定所有属性的默认值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String = <span class="string">""</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>通常需要复制一个改变其某些属性的对象，但是其他属性保持不变。这就是<strong>copy()</strong>函数的由来。对于上述User类，其实现如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(name: <span class="type">String</span> = this.name, age: <span class="type">Int</span> = this.age)</span></span> = User(name, age)</span><br></pre></td></tr></table></figure>
<p>有copy可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jack = User(name = <span class="string">"Jack"</span>, age = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> olderJack = jack.copy(age = <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="数据类和解构声明（Destructuring-Declarations）"><a href="#数据类和解构声明（Destructuring-Declarations）" class="headerlink" title="数据类和解构声明（Destructuring Declarations）"></a>数据类和解构声明（Destructuring Declarations）</h3><p>为数据类生成的组件函数（Component functions）可用于解构声明：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jane = User(<span class="string">"Jane"</span>, <span class="number">35</span>)</span><br><span class="line"><span class="keyword">val</span> (name, age) = jane</span><br><span class="line">println(<span class="string">"<span class="variable">$name</span>, <span class="variable">$age</span> years of age"</span>) <span class="comment">// prints "Jane, 35 years of age"</span></span><br></pre></td></tr></table></figure>
<h3 id="标准数据类"><a href="#标准数据类" class="headerlink" title="标准数据类"></a>标准数据类</h3><p>标准库提供了<strong>Pair</strong>和<strong>Triple</strong>。在大多数情况下，命名数据类是更好的设计选择，因为这样通过为属性提供有意义的名称来使代码可读性更强。</p>
<h2 id="密封类（Sealed-Classes）"><a href="#密封类（Sealed-Classes）" class="headerlink" title="密封类（Sealed Classes）"></a>密封类（Sealed Classes）</h2><p>当值可以具有来自有限集合的类型之一，但不能具有任何其他类型时，密封类用于表示受限类层次结构。它们在某种意义上是枚举类的扩展：枚举类型的值的集合也受到限制，但每个枚举常量仅作为单个实例存在，而密封类的子类可以包含多个含有状态的实例。</p>
<p>将<strong>sealed</strong>修饰符放在类名之前来声明一个密封类。密封类可以有子类，但是都必须在与密封类相同的文件中声明。（在Kotlin 1.1之前，规则更为严格：类必须嵌套在密封类的声明内）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span></span>(<span class="keyword">val</span> number: <span class="built_in">Double</span>) : Expr()</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> e1: Expr, <span class="keyword">val</span> e2: Expr) : Expr()</span><br><span class="line"><span class="keyword">object</span> NotANumber : Expr()</span><br></pre></td></tr></table></figure>
<p>（上面的例子使用了Kotlin 1.1的另外一个新功能：数据类可以继承其他类，包括密封类）</p>
<p>注意：继承密封类的子类（间接继承者）的类可以放置在任何位置，而不必在同一个文件中。</p>
<p>使用密封类的关键好处是在<strong>when</strong>表达式中使用的时候。如果可以验证语句涵盖所有情况，则不需要在语句中添加一个<strong>else</strong>子句。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(expr: <span class="type">Expr</span>)</span></span>: <span class="built_in">Double</span> = <span class="keyword">when</span>(expr) &#123;</span><br><span class="line">    <span class="keyword">is</span> Const -&gt; expr.number</span><br><span class="line">    <span class="keyword">is</span> Sum -&gt; eval(expr.e1) + eval(expr.e2)</span><br><span class="line">    NotANumber -&gt; <span class="built_in">Double</span>.NaN</span><br><span class="line">    <span class="comment">// the `else` clause is not required because we've covered all the cases</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>和Java一样，Kotlin中的类可以有类型参数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="type">T</span>&gt;</span>(t: T) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，要创建一个类的实例，需要提供类型参数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> box: Box&lt;<span class="built_in">Int</span>&gt; = Box&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>但是，如果可以推断参数，例如 从构造函数参数或其他方式，可以省略类型参数：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> box = Box(<span class="number">1</span>) <span class="comment">// 1 has type Int, so the compiler figures out that we are talking about Box&lt;Int&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="变型（Variance）"><a href="#变型（Variance）" class="headerlink" title="变型（Variance）"></a>变型（Variance）</h3><p>Java类型系统中最棘手的部分之一是通配符类型。但Kotlin没有。相反，它还有另外两个东西：声明变型和类型投影（declaration-site variance and type projections）。</p>
<p>首先，想想为什么Java需要这些神秘的通配符。问题在Effective Java中作出了解释：使用界限通配符来增加API的灵活性。首先，Java中的泛型类型是不变的（invariant），这意味着List&lt;String&gt;不是List&lt;Object&gt;的子类型。为什么这样？如果List不是不变的（invariant），那么它将不会比Java的数组更好，因为下面的代码将在运行时编译并引发异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line">List&lt;String&gt; strs = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Object&gt; objs = strs; <span class="comment">// !!! The cause of the upcoming problem sits here. Java prohibits this!</span></span><br><span class="line">objs.add(<span class="number">1</span>); <span class="comment">// Here we put an Integer into a list of Strings</span></span><br><span class="line">String s = strs.get(<span class="number">0</span>); <span class="comment">// !!! ClassCastException: Cannot cast Integer to String</span></span><br></pre></td></tr></table></figure>
<p>所以，Java禁止这样的事情来保证运行时的安全。但这有一些影响。例如，考虑Collection接口的addAll()方法。这个方法的签名是什么？直觉是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; ... </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;E&gt; items)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，无法做如下简单的事情（这些事情是完全安全的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyAll</span><span class="params">(Collection&lt;Object&gt; to, Collection&lt;String&gt; from)</span> </span>&#123;</span><br><span class="line">  to.addAll(from); <span class="comment">// !!! Would not compile with the naive declaration of addAll:</span></span><br><span class="line">                   <span class="comment">//       Collection&lt;String&gt; is not a subtype of Collection&lt;Object&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是为什么addAll()的实际签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; ... </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; items)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通配符类型参数 <strong>? extends E</strong> 表示此方法接受<strong>E</strong>的一些子类的对象的集合，而不是<strong>E</strong>本身。这意味着可以安全地读取<strong>E</strong>‘s（集合的元素是E的子类的实例），但不能写入它，因为不知道什么对象符合<strong>E</strong>的未知子类型。针对这个限制，需要有这样的行为：Collection&lt;String&gt;是Collection&lt;? extends Object&gt;的子类。换句话讲，带<strong>extends</strong>界限（上界）的通配符使得类型是协变的（covariant）。</p>
<p>理解这个技巧很简单：如果只能从集合中获取数据项，那么使用String集合并从中读取Object集合是可以的。相反，如果只能将数据项存入集合中，则可以将String集合存入Object集合中：在Java中List&lt;? super String&gt;是List&lt;Object&gt;的超类。</p>
<p>后者被称为逆变性（contravariance），并且对于List&lt;? super String&gt;只能调用接受String作为参数的方法（例如，可以调用add(String)或set(int, String))，而如果调用List&lt;T&gt;中返回T的函数，则不会得到一个String，而是一个Object。</p>
<p>Joshua Bloch称只能读取的对象为生产者（Producers），只能写入的对象为消费者（Consumers）。他建议：“<em>为了最大程度的灵活性，在表示生产者或消费者的输入参数上使用通配符类型</em>”，并提出以下助记符：</p>
<p><em>PECS代表Producer-Extends, Consumer-Super.</em></p>
<p>注意：如果使用生产者对象，例如List&lt;? extends Foo&gt;，则不能在该对象上调用add()或set()，但这并不意味着该对象是不可变的（immutable）：例如，仍然可以调用clear()从列表中删除所有数据项，因为clear()根本不需要任何参数。通配符（或其他类型的变型）保证的唯一的事情是类型安全（type safety）。不可变性完全是另一回事。</p>
<h3 id="声明处变型（Declaration-site-variance）"><a href="#声明处变型（Declaration-site-variance）" class="headerlink" title="声明处变型（Declaration-site variance）"></a>声明处变型（Declaration-site variance）</h3><p>假设有一个泛型接口Source&lt;T&gt;，没有任何接收T作为参数的方法，只有返回T的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Source</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">nextT</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将Source&lt;String&gt;的实例存储在Source&lt;Object&gt;类型的变量中是非常安全的-没有调用消费者方法。但Java不知道这一点，并且仍然禁止这么做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(Source&lt;String&gt; strs)</span> </span>&#123;</span><br><span class="line">  Source&lt;Object&gt; objects = strs; <span class="comment">// !!! Not allowed in Java</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要解决这个问题，必须声明Source&lt;? extends Object&gt;，这是没有意义的，因为可以像之前那样调用该变量所有相同的方法，所以并没有通过更复杂的类型添加值。但编译器不知道。</p>
<p>在Kotlin中，有一种方式可以向编译器解释这种事情。这称为声明处变型：通过注解类型参数<strong>T</strong>的来源，以确保它只从Source&lt;T&gt;的成员中返回（生产），而不会被消费。为此提供<strong>out</strong>修饰符：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">nextT</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(strs: <span class="type">Source</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> objects: Source&lt;Any&gt; = strs <span class="comment">// This is OK, since T is an out-parameter</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般规则是：当C类的类型参数T被声明为<strong>out</strong>时，就只能在C的成员的<strong>out</strong>位置出现，但结果是C&lt;Base&gt;可以安全地作为C&lt;Derived&gt;的超类。</p>
<p>换种说法，当C类在类型参数参数为T时是协变的（covariant），或者说是T是协变类型参数。可以认为C是T的生产者（producer），而不是T的消费者（consumer）。</p>
<p><strong>out</strong>修饰符称为变型注解（variance annotation），并且由于同处于类型参数声明处，所以称之为声明处变型（declaration-site variance）。与Java的使用处变型不同，其中类型中的通配符用于使类型协变。</p>
<p>除了<strong>out</strong>，Kotlin还提供了另外一个的变型注解：<strong>in</strong>。它使一个类型参数逆变（contravariant）：它只能被消费而不会被生产。逆变类的一个很好的例子是Comparable：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Comparable</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(x: <span class="type">Comparable</span>&lt;<span class="type">Number</span>&gt;)</span></span> &#123;</span><br><span class="line">    x.compareTo(<span class="number">1.0</span>) <span class="comment">// 1.0 has type Double, which is a subtype of Number</span></span><br><span class="line">    <span class="comment">// Thus, we can assign x to a variable of type Comparable&lt;Double&gt;</span></span><br><span class="line">    <span class="keyword">val</span> y: Comparable&lt;<span class="built_in">Double</span>&gt; = x <span class="comment">// OK!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>in和out两词是自解释的（因为它们已经在C＃中成功使用了一段时间），因此上面提到的助记符并不是真正需要的，可以改写为更高的目的：</p>
<p><strong>The Existential Transformation: Consumer in, Producer out!</strong></p>
<h3 id="类型投影（Type-projections）"><a href="#类型投影（Type-projections）" class="headerlink" title="类型投影（Type projections）"></a>类型投影（Type projections）</h3><h4 id="使用处变型：类型投影"><a href="#使用处变型：类型投影" class="headerlink" title="使用处变型：类型投影"></a>使用处变型：类型投影</h4><p>将类型参数T声明为<strong>out</strong>非常方便，而且可以避免在使用处子类型的麻烦，但是某些类实际上不能仅限于返回T！一个很好的例子是Array：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> size: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">T</span>)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这这个类既不能是协变的也不能是逆变的。这会在一定程度上降低灵活性。考虑下面的函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(from: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;, to: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;</span><br><span class="line">    assert(from.size == to.size)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> from.indices)</span><br><span class="line">        to[i] = from[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数将数据项从一个数组复制到另一个数组。实际应用如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ints: Array&lt;<span class="built_in">Int</span>&gt; = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> any = Array&lt;Any&gt;(<span class="number">3</span>) &#123; <span class="string">""</span> &#125;</span><br><span class="line">copy(ints, any) <span class="comment">// Error: expects (Array&lt;Any&gt;, Array&lt;Any&gt;)</span></span><br></pre></td></tr></table></figure>
<p>在这里遇到了同样熟悉的问题：Array&lt;T&gt;中的T是不可变型的（invariant），因此Array&lt;Int&gt;和Array&lt;Any&gt;互不为对方子类型。为什么？因为复制可能会有不正确的操作，比如可能尝试写入字符串到from中，如果实际上传递了一个Int的数组，那么将会抛出ClassCastException异常。</p>
<p>那么，唯一需要确保的是copy()不会做不正确的操作。为阻止向from写入，可以这样：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(from: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">Any</span>&gt;, to: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是类型投影：这里的from不仅仅是一个数组，而是一个投影：只能调用那些返回类型参数T的方法，在这种情况下，意味着我们只能调用get()。这是处理使用处变型的方法，并且类似于Java的Array&lt;? extends Object&gt;，但更简单。</p>
<p>当然也可以用<strong>in</strong>做投影：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fill</span><span class="params">(dest: <span class="type">Array</span>&lt;<span class="type">in</span> <span class="type">String</span>&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Array&lt;in String&gt;对应于Java中的Array&lt;? super String&gt;，即可以将CharSequence数组或Object数组传递给fill()函数。</p>
<h4 id="星投影（Star-projections）"><a href="#星投影（Star-projections）" class="headerlink" title="星投影（Star-projections）"></a>星投影（Star-projections）</h4><p>如果对类型参数一无所知，但仍然希望安全的使用它。保险的方法就是定一个该范型的投影，即该泛型的每个具体实例都将是该投影的子类型。</p>
<p>Kotlin为此提供了所谓的星投影语法：</p>
<ul>
<li>对于Foo&lt;out T&gt;，其中T是具有上界TUpper的协变类型参数，Foo&lt;*&gt;相当于Foo&lt;out TUpper&gt;。这意味着当T未知时，可以从Foo&lt;*&gt;安全地读取TUpper的值</li>
<li>对于Foo&lt;in T&gt;，其中T是逆变类型参数，Foo&lt;*&gt;相当于Foo&lt;in Nothing&gt;。这意味着当T未知时，没有什么可以安全的写入Foo&lt;*&gt;</li>
<li>对于Foo&lt;T&gt;，其中T是具有上界TUpper的不变类型参数，Foo&lt;*&gt;相当于读取值的Foo&lt;out TUpper&gt;和写入值的Foo&lt;in Nothing&gt;</li>
</ul>
<p>如果泛型具有多个类型参数，则可以单独地投影每个类型参数。例如，如果类型被声明为interface Function&lt;in T, out U&gt;，则可以设想到以下星投影：</p>
<ul>
<li>Function&lt;*, String&gt; 表示 Function&lt;in Nothing, String&gt;;</li>
<li>Function&lt;Int, *&gt; 表示 Function&lt;Int, out Any?&gt;;</li>
<li>Function&lt;*, *&gt; 表示 Function&lt;in Nothing, out Any?&gt;.</li>
</ul>
<p>注意：星投影非常像Java原始类型，但是是安全的。</p>
<h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><p>不仅类可以拥有类型参数，函数也可以拥有类型参数。类型参数放在函数名之前：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">singletonList</span><span class="params">(item: <span class="type">T</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">basicToString</span><span class="params">()</span></span> : String &#123;  <span class="comment">// extension function</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要调用泛型函数，需要在函数名后的调用位置指定类型参数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = singletonList&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>能够替代给定类型参数的所有可能类型的集合可以通过泛型约束（generic constraints）进行限制。</p>
<h4 id="上界（Upper-bounds）"><a href="#上界（Upper-bounds）" class="headerlink" title="上界（Upper bounds）"></a>上界（Upper bounds）</h4><p>最常见的类型约束是上界，对应于Java中的<em>extends</em>关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">sort</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒号之后指定的类型就是上界：只有Comparable&lt;T&gt;的子类型才可以替换<strong>T</strong>。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// OK. Int is a subtype of Comparable&lt;Int&gt;</span></span><br><span class="line">sort(listOf(HashMap&lt;<span class="built_in">Int</span>, String&gt;())) <span class="comment">// Error: HashMap&lt;Int, String&gt; is not a subtype of Comparable&lt;HashMap&lt;Int, String&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p>默认上界（如果没有指定）为<strong>Any?</strong>。在尖括号内只能指定一个上界。如果同一类型参数需要多个上界，需要一个单独的<strong>where</strong>子句：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">cloneWhenGreater</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;, threshold: <span class="type">T</span>)</span></span>: List&lt;T&gt;</span><br><span class="line">    where T : Comparable,</span><br><span class="line">          T : Cloneable &#123;</span><br><span class="line">  <span class="keyword">return</span> list.filter &#123; it &gt; threshold &#125;.map &#123; it.clone() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>类可以嵌套在其他类中</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> demo = Outer.Nested().foo() <span class="comment">// == 2</span></span><br></pre></td></tr></table></figure>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>类可以被标记为<strong>inner</strong>这样就能够访问外部类的成员。内部类持有外部类对象的引用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> demo = Outer().Inner().foo() <span class="comment">// == 1</span></span><br></pre></td></tr></table></figure>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类的实例是通过<span style="color:#497bb7">对象表达式</span>创建的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.addMouseListener(<span class="keyword">object</span>: MouseAdapter() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果对象是函数式的Java接口的实例（例如具有单个抽象方法的Java接口），则可以使用前缀为接口类型的lambda表达式来创建它。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listener = ActionListener &#123; println(<span class="string">"clicked"</span>) &#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>枚举类的最基本用法是实现类型安全的枚举</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">    NORTH, SOUTH, WEST, EAST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个枚举常量都是一个对象。枚举常量用逗号分隔。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>因为每个枚举都是枚举类的实例，所以它们可以被初始化</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>(<span class="keyword">val</span> rgb: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        RED(<span class="number">0xFF0000</span>),</span><br><span class="line">        GREEN(<span class="number">0x00FF00</span>),</span><br><span class="line">        BLUE(<span class="number">0x0000FF</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p>枚举常量也可以声明自己的匿名类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolState</span> </span>&#123;</span><br><span class="line">    WAITING &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span> = TALKING</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    TALKING &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span> = WAITING</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span>: ProtocolState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以拥有对应的方法，以及重写基本方法。注意：如果枚举类定义了任何成员，则需要使用分号将枚举常量定义与成员定义分开，就像在Java中一样。</p>
<h3 id="使用枚举常量"><a href="#使用枚举常量" class="headerlink" title="使用枚举常量"></a>使用枚举常量</h3><p>像Java一样，Kotlin中的枚举类具有合成方法，允许列出定义的枚举常量，并通过名称获取枚举常量。这些方法的签名如下（假设枚举类的名称为EnumClass）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EnumClass.valueOf(value: String): EnumClass</span><br><span class="line">EnumClass.values(): Array&lt;EnumClass&gt;</span><br></pre></td></tr></table></figure>
<p>如果指定的名称与类中定义的任何枚举常量不匹配，<strong>valueOf()</strong>方法将抛出<strong>IllegalArgumentException</strong>异常。</p>
<p>从Kotlin 1.1开始，可以使用<strong>enumValues&lt;T&gt;()</strong>和<strong>enumValueOf&lt;T&gt;()</strong>函数以泛型方式访问枚举类中的常量：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">RGB</span> </span>&#123; RED, GREEN, BLUE &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : Enum&lt;T&gt;</span>&gt; <span class="title">printAllValues</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(enumValues&lt;T&gt;().joinToString &#123; it.name &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printAllValues&lt;RGB&gt;() <span class="comment">// prints RED, GREEN, BLUE</span></span><br></pre></td></tr></table></figure>
<p>每个枚举常量都具有在枚举类声明中获取其名称和位置的属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String</span><br><span class="line"><span class="keyword">val</span> ordinal: <span class="built_in">Int</span></span><br></pre></td></tr></table></figure>
<p>枚举常量还实现了<span style="color:#497bb7">Comparable</span>接口，自然顺序是在枚举类中定义它们的顺序。</p>
<h2 id="对象表达式和声明"><a href="#对象表达式和声明" class="headerlink" title="对象表达式和声明"></a>对象表达式和声明</h2><p>有时候需要创建一个对类稍微有点修改的对象，而不需要明确地声明一个新的子类。Java使用匿名内部类来处理这种情况。Kotlin用对象表达式和对象声明略微概括了这个概念。</p>
<h3 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h3><p>要创建一个继承某种类型（或某些类型）的匿名类的对象，这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果超类具有构造函数，则必须传递相应的构造函数参数。多个超类可以用逗号分隔，跟在冒号后面：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(x: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">val</span> y: <span class="built_in">Int</span> = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ab: A = <span class="keyword">object</span> : A(<span class="number">1</span>), B &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> y = <span class="number">15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时候需要的“只是一个对象”，没有任何特殊的超类，可以简单地说：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> adHoc = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> y: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    print(adHoc.x + adHoc.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：匿名对象只能在局部（local）和私有（private）声明中作为类型使用。如果使用匿名对象作为公共（public）函数的返回类型或公共（public）属性的类型，则该函数或属性的实际类型将是匿名对象声明的超类，如果没有声明任何超类则实际类型为Any。在匿名对象中添加的成员将无法访问。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Private function, so the return type is the anonymous object type</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> x: String = <span class="string">"x"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Public function, so the return type is Any</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">publicFoo</span><span class="params">()</span></span> = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> x: String = <span class="string">"x"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> x1 = foo().x        <span class="comment">// Works</span></span><br><span class="line">        <span class="keyword">val</span> x2 = publicFoo().x  <span class="comment">// ERROR: Unresolved reference 'x'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像Java匿名内部类一样，对象表达式中的代码可以访问闭合范围内的变量。（与Java不同，这些变量不需要用final修饰）</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countClicks</span><span class="params">(window: <span class="type">JComponent</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> clickCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> enterCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">            clickCount++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">            enterCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h3><p><span style="color:#497bb7">Singleton</span>是一个非常有用的模式，Kotlin（Scala之后）可以很容易地声明单例模式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DataProviderManager &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">registerDataProvider</span><span class="params">(provider: <span class="type">DataProvider</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> allDataProviders: Collection&lt;DataProvider&gt;</span><br><span class="line">        <span class="keyword">get</span>() = <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这被称为对象声明，跟在<strong>object</strong>关键字后面的是对象名。就像变量声明一样，对象声明不是表达式，不能在赋值语句的右侧使用。</p>
<p>要引用对象，直接使用它的名字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataProviderManager.registerDataProvider(...)</span><br></pre></td></tr></table></figure>
<p>这样的对象可以有超类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DefaultListener : MouseAdapter() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：对象声明不能是局部的（例如直接嵌套在函数内），但是可以嵌套在其他对象声明或非内部类中。</p>
<h3 id="伴随对象-1"><a href="#伴随对象-1" class="headerlink" title="伴随对象"></a>伴随对象</h3><p>类中的对象声明可以用<strong>companion</strong>关键字标记：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Factory &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以简单地使用类名作为限定符来调用伴随对象的成员：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> instance = MyClass.create()</span><br></pre></td></tr></table></figure>
<p>伴随对象的名称可以省略，在这种情况下将使用名称<strong>Companion</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x = MyClass.Companion</span><br></pre></td></tr></table></figure>
<p>注意：尽管伴随对象的成员看起来像其他语言中的静态成员，但在运行时它们仍然是实际对象的实例成员，例如可以实现接口：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Factory&lt;MyClass&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果在JVM上使用<strong>@JvmStatic</strong>注解，则可以将伴随对象的成员作为实际静态方法和字段生成。</p>
<h3 id="对象表达式和声明的区别"><a href="#对象表达式和声明的区别" class="headerlink" title="对象表达式和声明的区别"></a>对象表达式和声明的区别</h3><p>对象表达式和对象声明之间存在一个重要的区别：</p>
<ul>
<li>对象表达式在使用的地方会立即（immediately）执行（并初始化）</li>
<li>对象声明在第一次被访问时才会被延迟（lazily）初始化</li>
<li>伴随对象是在对应的类被加载（解析）时初始化的，和Java中的静态初始化是对应的</li>
</ul>
<h2 id="代理（Delegation）"><a href="#代理（Delegation）" class="headerlink" title="代理（Delegation）"></a>代理（Delegation）</h2><h3 id="类代理"><a href="#类代理" class="headerlink" title="类代理"></a>类代理</h3><p>代理模式（Delegation pattern）是实现继承的一个很好的替代方案，而且Kotlin不需要什么样板代码就能支持这一点。Derived类可以继承Base接口，并将其所有的公共方法委托给指定的对象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseImpl</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>) : Base &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123; print(x) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(b: Base) : Base <span class="keyword">by</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> b = BaseImpl(<span class="number">10</span>)</span><br><span class="line">    Derived(b).print() <span class="comment">// prints 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Derived的父类列表中的<strong>by</strong>子句表示b将存储在Derived的内部对象中，编译器将生成所有转发到b中去的Base的方法。</p>
<p>注意：重写（override）会像期望的那样：编译器会使用重写的实现而不是委托对象中的替代实现。如果添加override fun print(){print(“abc”)}到Derived，程序将打印“abc”而不是“10”。</p>
<h2 id="代理属性（Delegated-Properties）"><a href="#代理属性（Delegated-Properties）" class="headerlink" title="代理属性（Delegated Properties）"></a>代理属性（Delegated Properties）</h2><p>有一些常见的属性，虽然可以在每次需要时手动实现它们，但更好的办法是一次实现多次使用，并放入库中。例子包括</p>
<ul>
<li>延迟属性：其值只在第一次访问时计算</li>
<li>可观察的属性：监听者收到对此属性的更改的通知</li>
<li>在map中存储属性，而不是存储每个属性的单独字段</li>
</ul>
<p>为了覆盖这些（和其他）情形，Kotlin支持代理属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p: String <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语法是：<strong>val/var <property name="">：<type> by <expression></expression></type></property></strong>。在<strong>by</strong>后面的表达式就是<em>代理（delegate）</em>，因为对应于属性的<strong>get()</strong>（和<strong>set()</strong>）将被<strong>getValue()</strong>和<strong>setValue()</strong>方法代理。属性代理不需要实现任何接口，但是必须v提供<strong>getValue()</strong>函数（如果是<strong>var</strong>还必须提供<strong>setValue()</strong>）。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="variable">$thisRef</span>, thank you for delegating '<span class="subst">$&#123;property.name&#125;</span>' to me!"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$value</span> has been assigned to '<span class="subst">$&#123;property.name&#125;</span> in <span class="variable">$thisRef</span>.'"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当从代理到Delegate的实例的p中进行读取时，将调用Delegate中的getValue()函数，因此第一个参数是从p读取的对象，第二个参数持有p的描述（例如，可以获取它的名称）。例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> e = Example()</span><br><span class="line">println(e.p)</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<pre><code>Example@33a17727, thank you for delegating ‘p’ to me!
</code></pre><p>类似地，当给p赋值时，会调用setValue()函数。前两个参数是相同的，第三个参数持有被赋予的值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.p = <span class="string">"NEW"</span></span><br></pre></td></tr></table></figure>
<p>打印：</p>
<pre><code>NEW has been assigned to ‘p’ in Example@33a17727.
</code></pre><p>注意：从Kotlin 1.1开始可以在函数或代码块中声明一个代理属性，因此不一定是类的成员。</p>
<h3 id="标准代理"><a href="#标准代理" class="headerlink" title="标准代理"></a>标准代理</h3><p>Kotlin标准库为几种常用的代理提供了工厂方法。</p>
<h4 id="延迟（Lazy）"><a href="#延迟（Lazy）" class="headerlink" title="延迟（Lazy）"></a>延迟（Lazy）</h4><p><strong>lazy()</strong>是一个接受lambda并返回一个<strong>Lazy&lt;T&gt;</strong>实例，该实例可以作为一个代理来实现一个延迟属性：第一次调用<strong>get()</strong>执行传递给<strong>lazy()</strong>的lambda并存储结果，随后每次调用<strong>get()</strong>只是返回存储的结果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lazyValue: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    println(<span class="string">"computed!"</span>)</span><br><span class="line">    <span class="string">"Hello"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(lazyValue)</span><br><span class="line">    println(lazyValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<p>computed!<br><br>Hello<br><br>Hello</p>
<p>默认情况下，延迟属性是<strong>同步的（synchronized）</strong>：该值只在一个线程中计算，所有线程将看到相同的值。如果不需要同步初始化代理，以至于多个线程可以同时执行，可以将<strong>LazyThreadSafetyMode.PUBLICATION</strong>作为参数传递给<strong>lazy()</strong>函数。如果确定初始化将始终发生在单线程上，则可以使用<strong>LazyThreadSafetyMode.NONE</strong>模式，该模式不会保证任何线程安全性和相关开销。</p>
<h3 id="可观察（Observable）"><a href="#可观察（Observable）" class="headerlink" title="可观察（Observable）"></a>可观察（Observable）</h3><p><strong>Delegates.observable()</strong>接受两个参数：初始值和用于修改的handler。每次给属性赋值（执行赋值之后）时，handler会被调用。它有三个参数：一个将被赋值的属性，旧值和新值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String <span class="keyword">by</span> Delegates.observable(<span class="string">"&lt;no name&gt;"</span>) &#123;</span><br><span class="line">        prop, old, new -&gt;</span><br><span class="line">        println(<span class="string">"<span class="variable">$old</span> -&gt; <span class="variable">$new</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User()</span><br><span class="line">    user.name = <span class="string">"first"</span></span><br><span class="line">    user.name = <span class="string">"second"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<p><no name=""> -&gt; first <br><br>first -&gt; second</no></p>
<p>如果想可以打断赋值并取消它，使用<strong>vetoable()</strong>代替<strong>observable()</strong>。传递给<strong>vetoable</strong>的<strong>handler</strong>会在赋新值之前调用。</p>
<h3 id="在Map中存储属性"><a href="#在Map中存储属性" class="headerlink" title="在Map中存储属性"></a>在Map中存储属性</h3><p>将属性的值存储在map中是常见的使用情形。这在应用程序中经常出现，如解析JSON或进行其他“动态”操作。在这种情况下，可以使用map实例作为代理属性的代理。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> map: Map&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span>     <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，构造函数接收一个map：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> user = User(mapOf(</span><br><span class="line">    <span class="string">"name"</span> to <span class="string">"John Doe"</span>,</span><br><span class="line">    <span class="string">"age"</span>  to <span class="number">25</span></span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p>代理属性从该map中获取值（通过字符串键 - 属性名称）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(user.name) <span class="comment">// Prints "John Doe"</span></span><br><span class="line">println(user.age)  <span class="comment">// Prints 25</span></span><br></pre></td></tr></table></figure>
<p>如果使用<strong>MutableMap</strong>代替只读的<strong>Map</strong>，那么这也适用于<strong>var</strong>的属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutableUser</span></span>(<span class="keyword">val</span> map: MutableMap&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span>     <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="局部代理属性（从1-1开始）"><a href="#局部代理属性（从1-1开始）" class="headerlink" title="局部代理属性（从1.1开始）"></a>局部代理属性（从1.1开始）</h3><p>可以将局部变量声明为代理属性。例如，可以创建一个局部延迟变量：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">example</span><span class="params">(computeFoo: ()</span></span> -&gt; Foo) &#123;</span><br><span class="line">    <span class="keyword">val</span> memoizedFoo <span class="keyword">by</span> lazy(computeFoo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (someCondition &amp;&amp; memoizedFoo.isValid()) &#123;</span><br><span class="line">        memoizedFoo.doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>memoizedFoo变量将只在第一次访问时计算。如果someCondition不符合，则该变量将不会被计算。</p>
<h3 id="属性代理的要求"><a href="#属性代理的要求" class="headerlink" title="属性代理的要求"></a>属性代理的要求</h3><p>这里总结了代理对象的要求。</p>
<p>对于只读属性（val），代理必须提供一个名为<strong>getValue</strong>的函数，该函数接收以下参数：</p>
<ul>
<li>thisRef —— 必须是相同的类型或属性所有者的父类（对于扩展属性 —— 被扩展的类型）</li>
<li>property —— 必须是KProperty&lt;*&gt;类型或其父类</li>
</ul>
<p>此函数必须返回与属性（或其子类型）相同的类型。</p>
<p>对于可变属性（var），代理必须另外提供一个名为<strong>setValue</strong>的函数，该函数接收以下参数：</p>
<ul>
<li>thisRef —— 和getValue()一样</li>
<li>property —— 和getValue()一样</li>
<li>新值 —— 必须与属性或其父类具有相同的类型</li>
</ul>
<p>可以将<strong>getValue()</strong>和/或<strong>setValue()</strong>函数可能作为代理类的成员函数或扩展函数提供。当需要将属性委托给最初没提供这些函数的对象时，扩展函数便于使用。这两个函数都需要使用<strong>operator</strong>关键字进行标记。</p>
<p>代理类可以实现包含所需<strong>operator</strong>方法的<strong>ReadOnlyProperty</strong>和<strong>ReadWriteProperty</strong>接口之一。这些接口在Kotlin标准库中声明：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ReadOnlyProperty</span>&lt;<span class="type">in R, out T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">R</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteProperty</span>&lt;<span class="type">in R, T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">R</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">R</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><p>在每个代理属性的底层实现下，Kotlin编译器会生成一个辅助属性并代理给它。例如，对于属性prop，生成隐藏属性prop$delegate，并且访问器的代码只是委托给这个附加属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prop: Type <span class="keyword">by</span> MyDelegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this code is generated by the compiler instead:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> prop$delegate = MyDelegate()</span><br><span class="line">    <span class="keyword">var</span> prop: Type</span><br><span class="line">        <span class="keyword">get</span>() = prop$delegate.getValue(<span class="keyword">this</span>, <span class="keyword">this</span>::prop)</span><br><span class="line">        <span class="keyword">set</span>(value: Type) = prop$delegate.setValue(<span class="keyword">this</span>, <span class="keyword">this</span>::prop, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin编译器在参数中提供有关prop的所有必要信息：第一个参数this引用到外部类C的实例，而this::prop是描述prop自身的KProperty类型的反射对象。</p>
<p>注意：直接在代码中引用<span style="color:#497bb7">绑定的可调用引用</span>的语法<strong>this::prop</strong>只有从Kotlin 1.1后才适用。</p>
<h3 id="提供代理（从1-1开始）"><a href="#提供代理（从1-1开始）" class="headerlink" title="提供代理（从1.1开始）"></a>提供代理（从1.1开始）</h3><p>通过定义<strong>provideDelegate</strong>操作符，可以扩展创建属性实现所代理的对象的逻辑。如果<strong>by</strong>右侧所使用的对象将<strong>provideDelegate</strong>定义为成员或扩展函数，则会调用该函数来创建属性代理实例。</p>
<p><strong>provideDelegate</strong>的一个可能使用场景是在创建属性时检查属性一致性，不仅仅在其getter或setter中。</p>
<p>例如，如果要在绑定之前检查属性名称，可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceLoader</span>&lt;<span class="type">T</span>&gt;</span>(id: ResourceID&lt;T&gt;) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">provideDelegate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            thisRef: <span class="type">MyUI</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            prop: <span class="type">KProperty</span>&lt;*&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: ReadOnlyProperty&lt;MyUI, T&gt; &#123;</span><br><span class="line">        checkProperty(thisRef, prop.name)</span><br><span class="line">        <span class="comment">// create delegate</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkProperty</span><span class="params">(thisRef: <span class="type">MyUI</span>, name: <span class="type">String</span>)</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">bindResource</span><span class="params">(id: <span class="type">ResourceID</span>&lt;<span class="type">T</span>&gt;)</span></span>: ResourceLoader&lt;T&gt; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUI</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> image <span class="keyword">by</span> bindResource(ResourceID.image_id)</span><br><span class="line">    <span class="keyword">val</span> text <span class="keyword">by</span> bindResource(ResourceID.text_id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>provideDelegate</strong>的参数与<strong>getValue</strong>相同：</p>
<ul>
<li>thisRef —— 必须是相同类型的或属性所有者的父类（对于扩展属性 —— 指被扩展的类型）</li>
<li>property —— 必须是KProperty&lt;*&gt;类型或其父类</li>
</ul>
<p>在创建MyUI实例期间为每个属性调用<strong>provideDelegate</strong>方法，并立即执行必要的验证。</p>
<p>如果没有这种中断属性和其代理之间的绑定的能力，为了实现相同的功能，必须显示传递属性名称，这不是很方便：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Checking the property name without "provideDelegate" functionality</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUI</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> image <span class="keyword">by</span> bindResource(ResourceID.image_id, <span class="string">"image"</span>)</span><br><span class="line">    <span class="keyword">val</span> text <span class="keyword">by</span> bindResource(ResourceID.text_id, <span class="string">"text"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MyUI.<span class="title">bindResource</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        id: <span class="type">ResourceID</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">        propertyName: <span class="type">String</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: ReadOnlyProperty&lt;MyUI, T&gt; &#123;</span><br><span class="line">   checkProperty(<span class="keyword">this</span>, propertyName)</span><br><span class="line">   <span class="comment">// create delegate</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在生成的代码中，调用<strong>provideDelegate</strong>方法来初始化辅助prop$delegate属性。将生成的属性声明的代码：val prop: Type by MyDelegate()与上面生成的代码（当provideDelegate方法不存在时）进行对比：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prop: Type <span class="keyword">by</span> MyDelegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this code is generated by the compiler</span></span><br><span class="line"><span class="comment">// when the 'provideDelegate' function is available:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="comment">// calling "provideDelegate" to create the additional "delegate" property</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> prop$delegate = MyDelegate().provideDelegate(<span class="keyword">this</span>, <span class="keyword">this</span>::prop)</span><br><span class="line">    <span class="keyword">val</span> prop: Type</span><br><span class="line">        <span class="keyword">get</span>() = prop$delegate.getValue(<span class="keyword">this</span>, <span class="keyword">this</span>::prop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<strong>provideDelegate</strong>方法只影响辅助属性的创建，并不影响为getter或setter生成的代码。</p>
<p>完结！！！</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Kotlin/" rel="tag"># Kotlin</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/14/android-multimedia/" rel="next" title="Android多媒体开发">
                <i class="fa fa-chevron-left"></i> Android多媒体开发
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/24/kotlin-functions/" rel="prev" title="Kotlin函数和lambda表达式">
                Kotlin函数和lambda表达式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2017/06/18/kotlin-classes/"
           data-title="Kotlin类和对象" data-url="http://zhupeng.space/2017/06/18/kotlin-classes/">
      </div>
    </div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://ob0r3vf26.bkt.clouddn.com/blog_logo.jpg"
                alt="朱鹏" />
            
              <p class="site-author-name" itemprop="name">朱鹏</p>
              <p class="site-description motion-element" itemprop="description">享受技术带来的快乐</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#类和继承"><span class="nav-number">1.</span> <span class="nav-text">类和继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类"><span class="nav-number">1.1.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数"><span class="nav-number">1.2.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二级构造函数"><span class="nav-number">1.3.</span> <span class="nav-text">二级构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建类的实例"><span class="nav-number">1.4.</span> <span class="nav-text">创建类的实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类成员"><span class="nav-number">1.5.</span> <span class="nav-text">类成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">1.6.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写方法"><span class="nav-number">1.7.</span> <span class="nav-text">重写方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写属性"><span class="nav-number">1.8.</span> <span class="nav-text">重写属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写规则"><span class="nav-number">1.9.</span> <span class="nav-text">重写规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类"><span class="nav-number">1.10.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伴随对象"><span class="nav-number">1.11.</span> <span class="nav-text">伴随对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性和字段"><span class="nav-number">2.</span> <span class="nav-text">属性和字段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#声明属性"><span class="nav-number">2.1.</span> <span class="nav-text">声明属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Getter和Setter"><span class="nav-number">2.2.</span> <span class="nav-text">Getter和Setter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后备字段（Backing-Fields）"><span class="nav-number">2.3.</span> <span class="nav-text">后备字段（Backing Fields）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后备属性（Backing-Properties）"><span class="nav-number">2.4.</span> <span class="nav-text">后备属性（Backing Properties）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译时常量"><span class="nav-number">2.5.</span> <span class="nav-text">编译时常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#延迟初始化属性（Late-Initialized-Properties）"><span class="nav-number">2.6.</span> <span class="nav-text">延迟初始化属性（Late-Initialized Properties）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#委托属性（Delegated-Properties）"><span class="nav-number">2.7.</span> <span class="nav-text">委托属性（Delegated Properties）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口"><span class="nav-number">3.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现接口"><span class="nav-number">3.1.</span> <span class="nav-text">实现接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口中的属性"><span class="nav-number">3.2.</span> <span class="nav-text">接口中的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决重写冲突"><span class="nav-number">3.3.</span> <span class="nav-text">解决重写冲突</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可见性修饰符"><span class="nav-number">4.</span> <span class="nav-text">可见性修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#包"><span class="nav-number">4.1.</span> <span class="nav-text">包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类和接口"><span class="nav-number">4.2.</span> <span class="nav-text">类和接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数-1"><span class="nav-number">4.3.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部声明"><span class="nav-number">4.4.</span> <span class="nav-text">局部声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块"><span class="nav-number">4.5.</span> <span class="nav-text">模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展"><span class="nav-number">5.</span> <span class="nav-text">扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数扩展"><span class="nav-number">5.1.</span> <span class="nav-text">函数扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展是被静态解析的"><span class="nav-number">5.2.</span> <span class="nav-text">扩展是被静态解析的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可空接收者（Nullable-Receiver）"><span class="nav-number">5.3.</span> <span class="nav-text">可空接收者（Nullable Receiver）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性扩展"><span class="nav-number">5.4.</span> <span class="nav-text">属性扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伴随对象扩展"><span class="nav-number">5.5.</span> <span class="nav-text">伴随对象扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展的域"><span class="nav-number">5.6.</span> <span class="nav-text">扩展的域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#声明扩展作为成员"><span class="nav-number">5.7.</span> <span class="nav-text">声明扩展作为成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动机（Motivation）"><span class="nav-number">5.8.</span> <span class="nav-text">动机（Motivation）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类"><span class="nav-number">6.</span> <span class="nav-text">数据类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#复制"><span class="nav-number">6.1.</span> <span class="nav-text">复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类和解构声明（Destructuring-Declarations）"><span class="nav-number">6.2.</span> <span class="nav-text">数据类和解构声明（Destructuring Declarations）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标准数据类"><span class="nav-number">6.3.</span> <span class="nav-text">标准数据类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#密封类（Sealed-Classes）"><span class="nav-number">7.</span> <span class="nav-text">密封类（Sealed Classes）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型"><span class="nav-number">8.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变型（Variance）"><span class="nav-number">8.1.</span> <span class="nav-text">变型（Variance）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#声明处变型（Declaration-site-variance）"><span class="nav-number">8.2.</span> <span class="nav-text">声明处变型（Declaration-site variance）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型投影（Type-projections）"><span class="nav-number">8.3.</span> <span class="nav-text">类型投影（Type projections）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用处变型：类型投影"><span class="nav-number">8.3.1.</span> <span class="nav-text">使用处变型：类型投影</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#星投影（Star-projections）"><span class="nav-number">8.3.2.</span> <span class="nav-text">星投影（Star-projections）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型函数"><span class="nav-number">8.4.</span> <span class="nav-text">泛型函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型约束"><span class="nav-number">8.5.</span> <span class="nav-text">泛型约束</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#上界（Upper-bounds）"><span class="nav-number">8.5.1.</span> <span class="nav-text">上界（Upper bounds）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套类"><span class="nav-number">9.</span> <span class="nav-text">嵌套类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类"><span class="nav-number">9.1.</span> <span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名内部类"><span class="nav-number">9.2.</span> <span class="nav-text">匿名内部类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举类"><span class="nav-number">10.</span> <span class="nav-text">枚举类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">10.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名类"><span class="nav-number">10.2.</span> <span class="nav-text">匿名类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用枚举常量"><span class="nav-number">10.3.</span> <span class="nav-text">使用枚举常量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象表达式和声明"><span class="nav-number">11.</span> <span class="nav-text">对象表达式和声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象表达式"><span class="nav-number">11.1.</span> <span class="nav-text">对象表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象声明"><span class="nav-number">11.2.</span> <span class="nav-text">对象声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伴随对象-1"><span class="nav-number">11.3.</span> <span class="nav-text">伴随对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象表达式和声明的区别"><span class="nav-number">11.4.</span> <span class="nav-text">对象表达式和声明的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代理（Delegation）"><span class="nav-number">12.</span> <span class="nav-text">代理（Delegation）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类代理"><span class="nav-number">12.1.</span> <span class="nav-text">类代理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代理属性（Delegated-Properties）"><span class="nav-number">13.</span> <span class="nav-text">代理属性（Delegated Properties）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标准代理"><span class="nav-number">13.1.</span> <span class="nav-text">标准代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#延迟（Lazy）"><span class="nav-number">13.1.1.</span> <span class="nav-text">延迟（Lazy）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可观察（Observable）"><span class="nav-number">13.2.</span> <span class="nav-text">可观察（Observable）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在Map中存储属性"><span class="nav-number">13.3.</span> <span class="nav-text">在Map中存储属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部代理属性（从1-1开始）"><span class="nav-number">13.4.</span> <span class="nav-text">局部代理属性（从1.1开始）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性代理的要求"><span class="nav-number">13.5.</span> <span class="nav-text">属性代理的要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转换规则"><span class="nav-number">13.6.</span> <span class="nav-text">转换规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提供代理（从1-1开始）"><span class="nav-number">13.7.</span> <span class="nav-text">提供代理（从1.1开始）</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朱鹏</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 您是第
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      个访客
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zhupeng"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("niXM6CtlVEgvUHEvwNmi0F7S", "LbP8mNzXFXinVUqMloOIy3fW");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
